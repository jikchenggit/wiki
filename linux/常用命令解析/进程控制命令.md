---
title: 进程控制命令
description: 进程控制命令
published: true
date: 2021-08-23T03:31:17.508Z
tags: 进程控制命令
editor: markdown
dateCreated: 2020-04-14T11:10:09.295Z
---

fg、bg、jobs、&、ctrl + z都是跟系统任务有关的，虽然现在基本上不怎么需要用到这些命令，但学会了也是很实用的
一。& 最经常被用到
这个用在一个命令的最后，可以把这个命令放到后台执行
二。ctrl + z
可以将一个正在前台执行的命令放到后台，并且暂停
三。jobs
查看当前有多少在后台运行的命令
四。fg
将后台中的命令调至前台继续运行
如果后台中有多个命令，可以用 fg %jobnumber将选中的命令调出，%jobnumber是通过jobs命令查到的后台正在执行的命令的序号(不是pid)
五。bg
将一个在后台暂停的命令，变成继续执行
如果后台中有多个命令，可以用bg %jobnumber将选中的命令调出，%jobnumber是通过jobs命令查到的后台正在执行的命令的序号(不是pid)

#Linux下使用Shell命令控制任务Jobs执行

下列命令可以用来操纵进程任务：
　　ps 列出系统中正在运行的进程；
　　kill 发送信号给一个或多个进程（经常用来杀死一个进程）；
　　jobs 列出当前shell环境中已启动的任务状态，若未指定jobsid，则显示所有活动的任务状态信息；如果报告了一个任务的终止(即任务的状态被标记为Terminated)，shell 从当前的shell环境已知的列表中删除任务的进程标识；
　　bg 将进程搬到后台运行（Background）；
　　fg 将进程搬到前台运行（Foreground）； 

　　将job转移到后台运行 
　　如果你经常在X图形下工作，你可能有这样的经历：通过终端命令运行一个GUI程序，GUI界面出来了，但是你的终端还停留在原地，你不能在shell中继续执行其他命令了，除非将GUI程序关掉。

　　为了使程序执行后终端还能继续接受命令，你可以将进程移到后台运行，使用如下命令运行程序： #假设要运行xmms

　　$xmms &

　　这样打开xmms后，终端的提示又回来了。现在xmms在后台运行着呢；但万一你运行程序时忘记使用“&”了，又不想重新执行；你可以先使用ctrl+z挂起程序，然后敲入bg命令，这样程序就在后台继续运行了。

　　概念：当前任务 

　　如果后台的任务号有2个，[1],[2]；如果当第一个后台任务顺利执行完毕，第二个后台任务还在执行中时，当前任务便会自动变成后台任务号码“[2]”的后台任务。所以可以得出一点，即当前任务是会变动的。当用户输入“fg”、“bg”和“stop”等命令时，如果不加任何引号，则所变动的均是当前任务。

　　察看jobs 
　　使用jobs或ps命令可以察看正在执行的jobs。 

　　jobs命令执行的结果，＋表示是一个当前的作业，减号表是是一个当前作业之后的一个作业，jobs -l选项可显示所有任务的PID,jobs的状态可以是running, stopped, Terminated,但是如果任务被终止了（kill），shell 从当前的shell环境已知的列表中删除任务的进程标识；也就是说，jobs命令显示的是当前shell环境中所起的后台正在运行或者被挂起的任务信息；

　　进程的挂起 

　　后台进程的挂起： 

　　在solaris中通过stop命令执行，通过jobs命令查看job号(假设为num)，然后执行stop %num；

　　在redhat中，不存在stop命令，可通过执行命令kill -stop PID，将进程挂起；

　　当要重新执行当前被挂起的任务时，通过bg %num 即可将挂起的job的状态由stopped改为running，仍在后台执行；当需要改为在前台执行时，执行命令fg %num即可；

　　前台进程的挂起：

　　ctrl+Z;

　　进程的终止 

　　后台进程的终止：
　　方法一：
　　通过jobs命令查看job号（假设为num），然后执行kill %num

　　方法二：
　　通过ps命令查看job的进程号（PID，假设为pid），然后执行kill pid 

　　前台进程的终止：

　　ctrl+c

　　kill的其他作用 
　　kill除了可以终止进程，还能给进程发送其它信号，使用kill -l 可以察看kill支持的信号。 

　　SIGTERM是不带参数时kill发送的信号，意思是要进程终止运行，但执行与否还得看进程是否支持。如果进程还没有终止，可以使用kill -SIGKILL pid，这是由内核来终止进程，进程不能监听这个信号。
===================
Unix/Linux下一般想让某个程序在后台运行，很多都是使用 & 在程序结尾来让程序自动运行。比如我们要运行mysql在后台：
/usr/local/mysql/bin/mysqld_safe --user=mysql &
　但是我们很多程序并不象mysqld一样可以做成守护进程，可能我们的程序只是普通程序而已，一般这种程序即使使用 & 结尾，如果终端关闭，那么程序也会被关闭。为了能够后台运行，我们需要使用nohup这个命令，比如我们有个start.sh需要在后台运行，并且希望在后台能够一直运行，那么就使用nohup：
nohup /root/start.sh &
在shell中回车后提示：
[~]$ appending output to nohup.out
原程序的的标准输出被自动改向到当前目录下的nohup.out文件，起到了log的作用。
但是有时候在这一步会有问题，当把终端关闭后，进程会自动被关闭，察看nohup.out可以看到在关闭终端瞬间服务自动关闭。
咨询红旗Linux工程师后，他也不得其解，在我的终端上执行后，他启动的进程竟然在关闭终端后依然运行。
在第二遍给我演示时，我才发现我和他操作终端时的一个细节不同：他是在当shell中提示了nohup成功后还需要按终端上键盘任意键退回到shell输入命令窗口，然后通过在shell中输入exit来退出终端；而我是每次在nohup执行成功后直接点关闭程序按钮关闭终端.。所以这时候会断掉该命令所对应的session，导致nohup对应的进程被通知需要一起shutdown。
这个细节有人和我一样没注意到，所以在这儿记录一下了。

附：nohup命令参考
nohup 命令
　　用途：不挂断地运行命令。
　　语法：nohup Command [ Arg ... ] [　& ]
　　描述：nohup 命令运行由 Command 参数和任何相关的 Arg 参数指定的命令，忽略所有挂断（SIGHUP）信号。在注销后使用 nohup 命令运行后台中的程序。要运行后台中的 nohup 命令，添加 & （ 表示"and"的符号）到命令的尾部。
　　无论是否将 nohup 命令的输出重定向到终端，输出都将附加到当前目录的 nohup.out 文件中。如果当前目录的 nohup.out 文件不可写，输出重定向到 $HOME/nohup.out 文件中。如果没有文件能创建或打开以用于追加，那么 Command 参数指定的命令不可调用。如果标准错误是一个终端，那么把指定的命令写给标准错误的所有输出作为标准输出重定向到相同的文件描述符。
　　退出状态：该命令返回下列出口值：
　　126 可以查找但不能调用 Command 参数指定的命令。
　　127 nohup 命令发生错误或不能查找由 Command 参数指定的命令。
　　否则，nohup 命令的退出状态是 Command 参数指定命令的退出状态。
　　nohup命令及其输出文件
　　nohup命令：如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用nohup命令。该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。nohup就是不挂起的意思( n ohang up)。
　　该命令的一般形式为：nohup command &
　　使用nohup命令提交作业
　　如果使用nohup命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中，除非另外指定了输出文件：
　　nohup command > myout.file 2>&1 &
　　在上面的例子中，输出被重定向到myout.file文件中。
　　使用 jobs 查看任务。
　　使用 fg %n　关闭。
　　另外有两个常用的ftp工具ncftpget和ncftpput，可以实现后台的ftp上传和下载，这样就可以利用这些命令在后台上传和下载文件了。
简单而有用的nohup命令在UNIX/LINUX中，普通进程用&符号放到后台运行，如果启动该程序的控制台logout，则该进程随即终止。
　　要实现守护进程，一种方法是按守护进程的规则去编程（本站有文章介绍过），比较麻烦；另一种方法是仍然用普通方法编程，然后用nohup命令启动程序：
　　nohup＜程序名＞&
　　则控制台logout后，进程仍然继续运行，起到守护进程的作用（虽然它不是严格意义上的守护进程）。
　　使用nohup命令后，原程序的的标准输出被自动改向到当前目录下的nohup.out文件，起到了log的作用，实现了完整的守护进程功能。
　　ygwu @ 2005年04月18日 上午10:03
　　For example：
　　如何远程启动WebLogic服务?
　　用telnet远程控制服务器，远程启动WEBLOGIC服务，启动后关闭telnet，WebLogic服务也跟着停止，这是因为使用telnet启动的进程会随着telnet进程的关闭而关闭。所以我们可以使用一些UNIX下的命令来做到不关闭。
　　使用如下命令：
　　nohup startWeblogic.sh&
　　如果想要监控标准输出可以使用：
　　tail -f nohup.out
　　当在后台运行了程序的时候，可以用jobs命令来查看后台作业的状态。在有多个后台程序时，要使用来参数的fg命令将不同序号的后台作业切换到前台上运行。
　　当用户启动一个进程的时候，这个进程是运行在前台，使用与相应控制终端相联系的标准输入、输出进行输入和输出。即使将进程的输入输出重定向，并将进程放在后台执行，进程仍然和当前终端设备有关系。正因为如此，在当前的登录会话结束时，控制终端设备将和登录进程相脱离，那么系统就向所有与这个终端相联系的进程发送SIGHUP的信号，通知进程线路已经挂起了，如果程序没有接管这个信号的处理，那么缺省的反应是进程结束。因此普通的程序并不能真正脱离登录会话而运行进程，为了使得在系统登录后还可以正常执行，只有使用命令nohup来启动相应程序。
　　使用命令nohup当然可以启动这样的程序，但nohup启动的程序在进程执行完毕就退出，而常见的一些服务进程通常永久的运行在后台，不向屏幕输出结果。在Unix中这些永久的后台进程称为守护进程（daemon）。守护进程通常从系统启动时自动开始执行，系统关闭时才停止。
　　在守护进程中，最重要的一个是超级守护进程inetd，这个进程接管了大部分网络服务，但并不是对每个服务都自己进行处理，而是依据连接请求，启动不同的服务程序与客户机打交道。inetd支持网络服务种类在它的设置文件/etc/inet.conf中定义。inet.conf文件中的每一行就对应一个端口地址，当inetd接受到连接这个端口的连接请求时，就启动相应的进程进行处理。使用inetd的好处是系统不必启动很多守护进程，从而节约了系统资源，然而使用inetd启动守护进程相应反应会迟缓一些，不适合用于被密集访问的服务进程