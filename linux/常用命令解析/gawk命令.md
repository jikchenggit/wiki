---
title: gawk命令
description: gawk命令
published: true
date: 2021-08-23T03:35:15.880Z
tags: gawk, awk
editor: markdown
dateCreated: 2020-07-17T08:06:27.176Z
---

# 快速使用手册
gawk程序是Unix上最初的awk程序的GNU版本。相较于sed编辑器使用的编辑器命令，awk程序采用了编程语言的形式，将流编辑又推进了一步。作为一份gawk功能的快速参考，本节将介绍gawk程序的基础知识。

### **B.2.1　gawk命令格式**

gawk程序的基本格式如下。

```
gawk options program file


```

表B-2列出了gawk程序支持的选项。

**表 B-2　gawk选项**

| 选项 | 描述 |
| --- | --- |
| `-F *fs*` | 指定用于分隔行中数据字段的文件分隔符 |
| `-f *file*` | 指定要读取的程序文件名 |
| `-v *var*=*value*` | 定义gawk程序中的一个变量及其默认值 |
| `-mf *N*` | 指定要处理的数据文件中的最大字段数 |
| `-mr *N*` | 指定数据文件中的最大记录数 |
| `-W *keyword*` | 指定gawk的兼容模式或警告等级。用`help`选项来列出所有可用的关键字 |

可以使用命令行选项轻松地定制gawk程序的功能。

### **B.2.2　使用gawk**

可以直接从命令行或shell脚本中使用gawk。本节将会演示如何使用gawk程序以及如何编写由`gawk`处理的脚本。

**1\. 从命令行上读取程序脚本**

gawk程序脚本是由一对花括号定义的。你必须将脚本命令放在两个花括号之间。由于gawk命令行假定脚本是一个文本字符串，你还必须用单引号来将脚本圈起来。下面是一个在命令行上指定的简单的gawk程序脚本。

```
$ gawk '{print $1}'


```

这个脚本会显示输入流中每行的第一个数据字段。

**2\. 在程序脚本中使用多条命令**

如果只能执行一条命令的话，这门编程语言也没多大用处。gawk编程语言允许你将多条命令组合成一个普通的程序。要在命令行上指定的程序脚本中使用多条命令，只需在每个命令之间放一个分号就可以了。

```
$ echo "My name is Rich" | gawk '{$4="Dave"; print $0}'
My name is Dave
$


```

该脚本执行了两条命令：先用一个不同的值替换第四个数据字段，再显示流中的整个数据行。

**3\. 从文件中读取程序**

跟sed编辑器一样，gawk编辑器允许你将程序存储在文件中，然后在命令行上引用它们。

```
$ cat script2
{ print $5 "'s userid is " $1 }
$ gawk -F: -f script2 /etc/passwd


```

gawk程序在输入数据流上执行了文件中指定的所有命令。

**4\. 在处理数据前运行脚本**

gawk程序还允许你指定程序脚本何时运行。默认情况下，gawk从输入中读取一行文本，然后对这行文本中的数据执行程序脚本。有时，你可能需要在处理数据之前（比如创建报告的标题）运行脚本。为了做到这点，可以使用`BEGIN`关键字。它会强制gawk先执行`BEGIN`关键字后面指定的程序脚本，然后再读取数据。

```
$ gawk 'BEGIN {print "This is a test report"}'
This is a test report
$


```

可以在`BEGIN`块中放置任何类型的`gawk`命令，比如给变量赋默认值。

**5\. 在处理数据后运行脚本**

类似于`BEGIN`关键字，`END`关键字允许你指定一个程序脚本，在gawk读取数据后执行。

```
$ gawk 'BEGIN {print "Hello World!"} {print $0} END {print
     "byebye"}' data1
Hello World!
This is a test
This is a test
This is another test.
This is another test.
byebye
$


```

gawk程序会先执行`BEGIN`块中的代码，然后处理输入流中的数据，最后执行`END`块中的代码。

### **B.2.3　gawk变量**

gawk程序不只是一个编辑器，还是一个完整的编程环境。正因为如此，有大量的命令和特性和gawk息息相关。本节将为你介绍使用gawk编程时需要知道的一些主要功能。

**1\. 内建变量**

gawk程序使用内建变量来引用程序数据中特定特性。本节将会为你介绍可用于gawk程序中的内建变量及其用法。

gawk程序将数据定义成记录和数据字段。**记录**是一行数据（默认用换行符分隔），而**数据字段**则是行中独立的数据元素（默认用空白字符分隔，比如空格或制表符）。

gawk程序使用数据字段来引用每条记录中的数据元素。表B-3描述了这些变量。

**表 B-3　gawk数据字段和记录变量**

| 变量 | 描述 |
| --- | --- |
| `$0` | 整条记录 |
| `$1` | 记录中的第1个数据字段 |
| `$2` | 记录中的第2个数据字段 |
| `$n` | 记录中的第*n*个数据字段 |
| `FIELDWIDTHS` | 一列由空格分隔的数字，定义了每个字段具体宽度 |
| `FS` | 输入字段分隔符 |
| `RS` | 输入记录分隔符 |
| `OFS` | 输出字段分隔符 |
| `ORS` | 输出字段分隔符 |

除了字段和记录分隔符变量，gawk还提供了其他一些内建变量，可以帮助你了解数据的相关情况以及从shell环境中提取信息。表B-4介绍了gawk中其他的内建变量。

**表 B-4　更多的gawk内建变量**

| 变量 | 描述 |
| --- | --- |
| `ARGC` | 当前命令行参数个数 |
| `ARGIND` | 当前文件在`ARGV`中的索引 |
| `ARGV` | 包含命令行参数的数组 |
| `CONVFMT` | 数字的转换格式（参见`printf`语句），默认值为`%.6g` |
| `ENVIRON` | 由当前shell环境变量及其值组成的关联数组 |
| `ERRNO` | 当读取或关闭输入文件发生错误时的系统错误号 |
| `FILENAME` | 用作gawk输入的数据文件的文件名 |
| `FNR` | 当前数据文件中的记录数 |
| `IGNORECASE` | 设成非零时，忽略gawk命令中出现的字符串的字符大小写 |
| `NF` | 数据文件中的字段总数 |
| `NR` | 已处理的输入记录数 |
| `OFMT` | 数字的输出格式，默认值为`%.6g` |
| `RLENGTH` | 由`match`函数所匹配的子串的长度 |
| `RSTART` | 由`match`函数所匹配的子串的起始位置 |

可以在gawk程序脚本中的任何地方使用内建变量，包括`BEGIN`和`END`代码块中。

**2\. 在脚本中给变量赋值**

在gawk程序中给变量赋值类似于在shell脚本中给变量赋值，两者都使用**赋值语句**。

```
$ gawk '
> BEGIN{
> testing="This is a test"
> print testing
> }'
This is a test
$


```

给变量赋值后，就可以在gawk脚本中任何地方使用该变量了。

**3\. 在命令行上给变量赋值**

也可以用`gawk`命令行为gawk程序给变量赋值。这允许你在正常代码外设置值，即时修改值。下面的例子使用命令行变量来显示文件中特定数据字段。

```
$ cat script1
BEGIN{FS=","}
{print $n}
$ gawk -f script1 n=2 data1
$ gawk -f script1 n=3 data1


```

这个特性是在gawk脚本中处理shell脚本数据的一个好办法。

### **B.2.4　gawk程序的特性**

gawk程序有一些特性使它非常便于数据操作，允许你创建gawk脚本来解析包括日志文件在内的几乎任何类型的文本文件。

**1\. 正则表达式**

可使用基础正则表达式（BRE）或扩展正则表达式（ERE）将程序脚本要处理的行过滤出来。

在使用正则表达式时，正则表达式必须出现在它所作用的程序代码的左花括号之前。

```
$ gawk 'BEGIN{FS=","} /test/{print $1}' data1
This is a test
$


```

**2\. 匹配操作符**

**匹配操作符**（matching operator）允许你将正则表达式限定在数据行中的特定数据字段上。匹配操作符是波浪线（`~`）。你可以指定匹配操作符、数据字段变量以及要匹配的正则表达式。

```
$1 ~ /^data/


```

这个表达式会过滤出第一个数据字段以文本data开头的记录。

**3\. 数学表达式**

除了正则表达式外，还可以在匹配模式中使用数学表达式。这个功能在匹配数据字段中的数字值时非常有用。举个例子，如果你要显示所有属于root用户组（组ID为`0`）的系统用户，可以使用如下脚本。

```
$ gawk -F: '$4 == 0{print $1}' /etc/passwd


```

这个脚本显示出第四个数据字段含有值`0`的所有行的第一个数据字段。

**4\. 结构化命令**

gawk程序支持本节讨论的如下结构化命令。

`if-then-else`语句：

```
if (condition) statement1; else statement2


```

`while`语句：

```
while (condition)
{
statements
}


```

`do-while`语句：

```
do {
    statements 
} while (condition)


```

`for`语句：

```
for(variable assignment; condition; iteration process)


```

这为gawk脚本程序员提供了大量的编程手段。可以利用它们编写出能够媲美其他高级语言程序功能的gawk程序。


# 参考手册
awk是linux下的一个命令，他对其他命令的输出，对文件的处理都十分强大，其实他更像一门编程语言，他可以自定义变量，有条件语句，有循环，有数组，有正则，有函数等。他读取输出，或者文件的方式是一行，一行的读，根据你给出的条件进行查找，并在找出来的行中进行操作，感觉他的设计思想，真的很简单，但是结合实际情况，具体操作起来就没有那么简单了。他有三种形势，awk，gawk，nawk，平时所说的awk其实就是gawk。

选项
-F 紧跟分隔符，表示读入的字段以输入的分隔符分割
-v 进入变量模式 可以进行变量的赋值及调用（调用不需要加$符）

1，变量

变 量	描述
$n	当前记录的第n个字段，字段间由 FS分隔。
$0	完整的输入记录。
ARGC	命 令行参数的数目。
ARGIND	命令行中当前文件的位置(从0开始算)。
ARGV	包 含命令行参数的数组。
CONVFMT	数字转换格式(默认值为%.6g)
ENVIRON	环 境变量关联数组。
ERRNO	最后一个系统错误的描述。
FIELDWIDTHS	字 段宽度列表(用空格键分隔)。
FILENAME	当前文件名。
FNR	同 NR，但相对于当前文件。
FS	字段分隔符(默认是任何空格)。
IGNORECASE	如 果为真，则进行忽略大小写的匹配。
NF	当前记录中的字段数。
NR	当 前记录数。
OFMT	数字的输出格式(默认值是%.6g)。
OFS	输 出字段分隔符(默认值是一个空格)。
ORS	输出记录分隔符(默认值是一个换行符)。
RLENGTH	由 match函数所匹配的字符串的长度。
RS	记录分隔符(默认是一个换行符)。
RSTART	由 match函数所匹配的字符串的第一个位置。
SUBSEP	数组下标分隔符(默认值是\034)。

2，运算符

运算符	描述
= += -= *= /= %= ^= **=	赋值
?:	C条件表达式
||	逻 辑或
&&	逻辑与
~ ~!	匹 配正则表达式和不匹配正则表达式
< <= > >= != ==	关 系运算符
空格	连接
+ -	加，减
* / &	乘，除与求余
+ - !	一元加，减和逻辑非
^ ***	求幂
++ --	增加或减少，作为前缀或后缀
$	字 段引用
in	数组成员

3，awk的正则

匹配符	描述
\Y	匹配一个单词开头或者末尾的空字符串
\B	匹配单词内的空字符串
\<	匹配一个单词的开头的空字符串，锚定开始
\>	匹配一个单词的末尾的空字符串，锚定末尾
\W	匹配一个非字母数字组成的单词
\w	匹配一个字母数字组成的单词
\'	匹配字符串末尾的一个空字符串
\‘	匹配字符串开头的一个空字符串

4，字符串函数

函数名	描述



|               函数               |                                                                                            描述                                                                                            |
| -------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `asort(*s* [,*d*])`              | 将数组*`s`*按数据元素值排序。索引值会被替换成表示新的排序顺序的连续数字。另外，如果指定了*`d`*，则排序后的数组会存储在数组*`d`*中                                                                  |
| `asorti(*s* [,*d*])`             | 将数组*`s`*按索引值排序。生成的数组会将索引值作为数据元素值，用连续数字索引来表明排序顺序。另外如果指定了*`d`*，排序后的数组会存储在数组*`d`*中                                                     |
| `gensub(*r*, *s*, *h* [, *t*])`  | 查找变量`$0`或目标字符串*`t`*（如果提供了的话）来匹配正则表达式`r`。如果*`h`*是一个以*`g`*或*`G`*开头的字符串，就用*`s`*替换掉匹配的文本。如果*`h`*是一个数字，它表示要替换掉第*`h`*处*`r`*匹配的地方 |
| `gsub(*r*, *s* [,*t*])`          | 查找变量`$0`或目标字符串*`t`*（如果提供了的话）来匹配正则表达式*`r`*。如果找到了，就全部替换成字符串*`s`*                                                                                        |
| `index(*s*, *t*)`                | 返回字符串*`t`*在字符串*`s`*中的索引值，如果没找到的话返回`0`                                                                                                                                 |
| `length([*s*])`                  | 返回字符串*`s`*的长度；如果没有指定的话，返回`$0`的长度                                                                                                                                       |
| `match(*s*, *r* [,*a*])`         | 返回字符串*`s`*中正则表达式*`r`*出现位置的索引。如果指定了数组*`a`*，它会存储*`s`*中匹配正则表达式的那部分                                                                                       |
| `split(*s*, *a* [,*r*])`         | 将*`s`*用`FS`字符或正则表达式*`r`*（如果指定了的话）分开放到数组*`a`*中。返回字段的总数                                                                                                         |
| `sprintf(*format*, *variables*)` | 用提供的*`format`*和*`variables`*返回一个类似于`printf`输出的字符串                                                                                                                          |
| `sub(*r*, *s* [,*t*])`           | 在变量`$0`或目标字符串*`t`*中查找正则表达式`r`的匹配。如果找到了，就用字符串*`s`*替换掉第一处匹配                                                                                                |
| `substr(*s*, *i* [,*n*])`        | 返回*`s`*中从索引值*`i`*开始的*`n`*个字符组成的子字符串。如果未提供*`n`*，则返回*`s`*剩下的部分                                                                                                 |
| `tolower(*s*)`                   | 将*`s`*中的所有字符转换成小写                                                                                                                                                               |
| `toupper(*s*)`                   | 将*`s`*中的所有字符转换成大写                                                                                                                                                               |

5，数学函数

函数名	返回值



                                                               |




|     函数      |                  描述                  |
| ------------- | -------------------------------------- |
| `atan2(x, y)` | *x*/*y* 的反正切，*x* 和*y* 以弧度为单位 |
| `cos(x)`      | *x* 的余弦，*x* 以弧度为单位             |
| `exp(x)`      | *x* 的指数函数                          |
| `int(x)`      | *x* 的整数部分，取靠近零一侧的值         |
| `log(x)`      | *x* 的自然对数                          |
| `rand( )`     | 比0大比1小的随机浮点值                   |
| `sin(x)`      | *x* 的正弦，*x* 以弧度为单位             |
| `sqrt(x)`     | *x* 的平方根                            |
| `srand(x)`    | 为计算随机数指定一个种子值               |

6. 时间函数

|                函数                 |                                          描述                                           |
| ----------------------------------- | --------------------------------------------------------------------------------------- |
| `mktime(*datespec*)`                | 将一个按YYYY MM DD HH MM SS \[DST\]格式指定的日期转换成时间戳值**1**                      |
| `strftime(*format* [,*timestamp*])` | 将当前时间的时间戳或timestamp（如果提供了的话）转化格式化日期（采用shell函数`date()`的格式） |
| `systime( )`                        | 返回当前时间的时间戳      
6，format的使用

要点：
1、其与print命令的最大不同是，printf需要指定format；
2、format用于指定后面的每个item的输出格式；
3、printf语句不会自动打印换行符；\\n

format格式的指示符都以%开头，后跟一个字符；如下：
%c: 显示字符的ASCII码；
%d, %i：十进制整数；
%e, %E：科学计数法显示数值；
%f: 显示浮点数；
%g, %G: 以科学计数法的格式或浮点数的格式显示数值；
%s: 显示字符串；
%u: 无符号整数；
%%: 显示%自身；

修饰符：
N: 显示宽度；
-: 左对齐；
+：显示数值符号；

# 使用例子
## ip 地址获取规范
```bash
ip addr show | awk 'BEGIN{FS="[/ ]+";OFS=" -- "} $NF~/eth/{print $NF,$3}'

ip addr show | awk 'BEGIN{FS="[/ ]+";OFS=" -- "}$2~"eth"{$3~"NO-CARRIER"?a=0:a=1}$NF~"eth"&&a{print $NF,$3}' 
```
## 去重
```bash
cat aaa | awk '!a[$1]++'
```
## 取出last 命令中统计登录次数
```bash
last |awk '$0!=""&&$2!~"boot"&&$3~"[[:digit:]]"{ips[$3]++}END{for(i in ips)printf "%18-s%10-d\n",i,ips[i]}' 
```

- `&&`表示 且,与

- `$0!=""`表示排除结果中的空行

- `$2!~"boot"`表示排除重启的记录

- `$3~"[[:digit:]]`表示第三个字段匹配数字而不是字符

- `{ips[$3]++}`表示把第三个字段即IP地址作为下标,组成一个数组`ips`,`IP`地址每出现一次,其出现次数累加一

- `END{for(i in ips)printf "%18-s%10-d\n",i,ips[i]}`

表示从数组中获取每个IP地址,及其出现的次数,并定义对齐方式和变量类型打印出来

## 打印UID 大于500 的用户
```bash
awk -F: '$3>=500  {print $1,$3}' /etc/passwd
```

## 取出数据库要导入的字段个数
```bash
awk -F , 'NR == 1''{print NF}' CARDS.csv 
```

## 截取文件名称,不要后缀
```bash
awk -F , 'NR == 1''{split(FILENAME,a,"[.]") ;print a[1]}' QNB_ACCOUNT_MASTER.csv 
```

## 自动创建需要导入CSV 的表.
```
awk -F , 'NR == 1''{split(FILENAME,a,"[.]") ;print " create table " a[1] " ( "}''NR == 1''{for(i=1;i<=NF;i++){if (i != NF) {print $i " character varying(255),"} else {print $i " character varying(255));"} }}' QNB_ACCOUNT_MASTER.csv 
```